
| key  | value                                             |
| ---- | ------------------------------------------------- |
| url  | https://atcoder.jp/contests/abc415/tasks/abc415_c |
| tags | #dp #bit                                          |
| lose | #lose/2025/09/06                                  |

## 考察

- 制約
	- $1 \le T \le 4 \times 10^4$, $1 \le v \le 2^N - 1$
- 問題理解
	- $S$ は危険な状態の一覧を表す
	- $N$ は 1 ~ N までの N この薬品があることを表す
	- 薬品 a, b を混ぜるとは、a ビット目が 1 の整数（= $2^{a-1}$）と、b ビット目が 1 の整数（$2^{b-1}$）を足すことを表す
	- 薬品 a, b が混ざった状態は、$2^{a-1} + 2^{b-1}$ である
	- 薬品 a, b, c, ... が混ざった状態は、$2^{a-1} + 2^{b-1} + 2^{c-1} + ...$ である、これを `v` とする
	- `S[v] == 0` であれば安全、`S[v] == 1` であれば危険である
- 考察
	- 薬品を混ぜる中で出現する部分和で `S[v] == 1` になるような `v` があってはならない
	- dp でいけそうじゃない？
	- `dp[i][v] = c`: 1 ~ i までの薬品を使うときの部分和として `v` を経由するパターン数が `c`
	- こうすると $1 \le i \le 18$, $1 \le v \le 2^{18} - 1$ なので事前計算しきれるのでは、いや $18!$ になるからだめか
	- あり得るパターンの全列挙は現実的ではない
	- 待った、$S$ は薬品を混ぜた後の状態が危険がどうかのフラグ一覧だから、$S$ の長さはすなわち、合計値が取りうる値を示す。
	- その合計が $5 \times 10^5$ 以下、ということは計算すべき合計値が $5 \times 10^5$ 以下ってことか、これなら dp で計算し尽くせるか？
- 解説
	- `dp[mask] = bool` 
		- 初期化: 各単一薬品の状態から開始
		- 遷移: 状態 `mask` に薬品 `i` を追加して `mask | (1 << i)` に遷移する
		- 終了状態: 状態 `(1 << N) - 1` に到達できるか

## 実装

```go
func Solve(r *Reader, w *Writer) {
	// t: O(4 * 10^4)
	for t := r.Int(); t > 0; t-- {
		n, s := r.Int(), r.Str()
		// 初期化
		// n: O(18)
		dp := make([]bool, 1<<n)
		for i := 0; i < n; i++ {
			// 薬品 i 単体の状態を表すビットマスク
			state := (1 << i)
			// 安全であれば到達可能
			if s[state-1] == '0' {
				dp[state] = true
			}
		}
		// 遷移: ある薬品を追加する前の状態としてありうるものをすべて試す
		// mask: O(2^n - 1) = O(5 * 10^5)
		for prevState := 1; prevState < (1 << n); prevState++ {
			// 到達不可能な状態ならスキップ
			// これにより、この状態への別の薬品の追加も到達不可能となる
			if !dp[prevState] {
				continue
			}
			// i: O(18)
			for i := 0; i < n; i++ {
				// ある状態に薬品 i を追加した状態を表すビットマスク
				state := (prevState | (1 << i))
				// 安全であれば到達可能
				if s[state-1] == '0' {
					dp[state] = true
				}
			}
		}
		w.Bool(dp[(1<<n)-1])
	}
}
```
