
| key  | value                                             |
| ---- | ------------------------------------------------- |
| url  | https://atcoder.jp/contests/abc418/tasks/abc418_d |
| tags | #dp #bit                                          |
| lose | #lose/2025/09/03                                  |

## 考察

- 論理演算の用途
	- AND：マスク処理
	- OR：ビット結合
	- NOT：信号反転、補数生成
	- XOR：ビット反転、暗号化、パリティチェック、加算器の半加算
	- NAND：万能ゲート（NAND ですべての演算を構成可能）
	- NOR：万能ゲート
	- XNOR = NOT(XOR)：ビット比較回路（2つのビットの等価チェック）、暗号化、パリティチェック
		- 複数ビット比較では各ビット位置で XNOR、すべての結果を AND することで全体の一致を判定可能
- 計算してみる
	- `0` -> NG
	- `1` -> OK
	- `00` -> `1` -> OK
	- `01` -> `0` -> NG
	- `10` -> `0` -> NG
	- `11` -> `1` -> OK
	- `000` -> (`10`, `01`) -> `0` -> NG
	- `111` -> `11` -> `1` -> OK
	- `0000` -> (`100`, `001`, `010`) -> (`00`, `11`) -> `1` -> OK
- 示唆
	- `0` と `1` の偶奇連続による性質
		- `0` が偶数個連続：`1` になる
		- `1` が偶数個連続：`1` になる
		- `0` が奇数個連続：`0` になる（単一の `0` は NG）
		- `1` が奇数個連続：`1` になる（単一の `1` も OK）
	- `XNOR` 演算での `0` の個数変化
		- `00` -> `1` -> `0` 個数が偶数変化
		- `01` -> `0` -> `0` 個数が不変
		- `10` -> `0` -> `0` 個数が不変
		- `11` -> `1` -> `0` 個数が不変
		- 操作を通じて `0` の偶奇は変化しない
		- したがって、美しい文字列は `0` の個数が偶数である必要がある（でないと消えない）
- 計算量
	- $O(N^2) = 4 \times 10^{10}$ -> NG

## 実装

### Brute-force: $O(N^2)$

- すべての部分文字列を実際に左側から圧縮する

```go
func simulate(s string) byte {
	if len(s) == 1 {
		return s[0]
	}
	for len(s) > 1 {
		next := ""
		for i := 0; i < len(s); i += 2 {
			if i+1 == len(s) {
				next += s[i:]
				continue
			}
			if s[i] == s[i+1] {
				next += "1"
			} else {
				next += "0"
			}
		}
		s = next
	}
	return s[0]
}

func Solve(r *Reader, w *Writer) {
	n, t := r.Int(), r.String()
	count := 0
	for i := 0; i < n; i++ {
		for j := i + 1; j <= n; j++ {
			substr := t[i:j]
			if simulate(substr) == '1' {
				count++
			}
		}
	}
	w.Println(count)
}
```

### DP: $O(N)$

- `0 <= r < n` について
- `dp[r][0]` = 部分文字列（$S[0,r],S[1,r],...S[r,r]$）のうち、`0` の個数が**偶数**のものの数
- `dp[r][1]` = 部分文字列（$S[0,r],S[1,r],...S[r,r]$）のうち、`0` の個数が**奇数**のものの数
- 遷移
	- `s[r] == '0'` の場合（= 部分文字列の末尾に `0` が追加される）
		- `dp[r+1][0] = dp[r][1]`
		- `dp[r+1][1] = dp[r][0] + 1`
	- `s[r] == '1'` の場合（= 部分文字列の末尾に `1` が追加される）
		- `dp[r+1][0] = dp[r][1] + 1`
		- `dp[r+1][1] = dp[r][0]`

```go
// 1. 配列を使った素直な　DP
func Solve(r *Reader, w *Writer) {
	n, t := r.Int(), r.String()
	dp := make([][2]int, n+1)
	for i := 0; i < len(dp); i++ {
		dp[i] = [2]int{0, 0}
	}
	c := 0
	for r := 1; r <= n; r++ {
		if t[r-1] == '0' {
			dp[r][0] = dp[r-1][1]
			dp[r][1] = dp[r-1][0] + 1
		} else {
			dp[r][0] = dp[r-1][0] + 1
			dp[r][1] = dp[r-1][1]
		}
		c += dp[r][0]
	}
	w.Println(c)
}
```

```go
// 2. 合計もループ内で計算できるので配列キャッシュを抜いた DP
func Solve(r *Reader, w *Writer) {
	n, t := r.Int(), r.String()
	e, o := 0, 0
	c := 0
	for r := 1; r <= n; r++ {
		if t[r-1] == '0' {
			e, o = o, e + 1
		} else {
			e, o = e + 1, o
		}
		c += e
	}
	w.Println(c)
}
```